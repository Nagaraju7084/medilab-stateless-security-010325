
UserManagement :

@SuppressWarnings("deprecation")
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
	@Override
	protected void configure(HttpSecurity http) throws Exception { //configure(HttpSecurity http) is used to define the urls to be protected
		//and define the authentication methods and also to define the various application artifacts such as cors to be enable
		http.authorizeRequests()
		.antMatchers("/").permitAll() //this will allow all urls to access meaning without security
		.antMatchers("/dashboard").authenticated() //should be authenticate
		.antMatchers("/doctor").authenticated() //should be authenticate
		.and()
		.formLogin() //either through form login
		.and()
		.httpBasic(); //or through httpbasic means via postman headers
	}
	
	//instead of default generated user details such as user and generated password
	//define our custom user details may be in memory user details manager or jdbc user details manager, etc
	//using AuthenticationManagerBuilder
	//AuthenticationManagerBuilder will build the AuthenticationManager
	//AuthenticationManager will be implemented by the AuthenticationProvider 
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception { //is used to build mostly for the custom authenticationprovider and custom userdetailsmanager, inmemoryuserdetailsmanager
		//AuthenticationManagerBuilder is used to build the AuthenticationManager, that AuthenticationManager will provides the Authentication details to the AuthenticationProvider
		//AuthenticationManagerBuilder is also used to define the UserDetailsManager to create the users schema
		auth.inMemoryAuthentication() //this inmemoryuserdetailsmanager take all these users and calling the userdetails => createuser
		//inMemoryAuthentication() => InMemoryUserDetailsManagerConfigurer => InMemoryUserDetailsManager => createUser
		//createUser(UserDetails user) = given user details
		//finally the users are added into the user map
		.withUser("admin").password("admin").authorities("admin") //our own user store using in memory
		.and()
		.withUser("user").password("user").authorities("user");
		//if we run the application, we will get the exception as : java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id "null"
		//because AuthenticationProvider will verify the password what we are enter with the password present in UserDetailsService using PasswordEncoder
		//this PasswordEncoder used by the AuthenticationProvider
		//that is the reason, while authenticating, AuthenticationProvider have not found any
		//PasswordEncoder, and hence we got the PasswordEncoder error here
		//configure PasswordEncoder
	}
	//seperating the passwordencoder
	@Bean
	public PasswordEncoder passwordEncoder(){
		return NoOpPasswordEncoder.getInstance();
	}
	@Override
	public void configure(WebSecurity web) throws Exception { //to static resources should have to be unsecure
		web.ignoring().antMatchers("/assets/**"); //this configure(WebSecurity web) is mostly used for ignoring the security check on the static resources
	}
}

//beans we can define with @Bean, those beans we can define in the class which annotated with @Configuration

==================jdbcauthentication============
@SuppressWarnings("deprecation")
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	private DataSource dataSource;
	@Override
	protected void configure(HttpSecurity http) throws Exception { 
		http.authorizeRequests()
		.antMatchers("/").permitAll()
		.antMatchers("/dashboard").authenticated()
		.antMatchers("/doctor").authenticated()
		.and()
		.formLogin()
		.and()
		.httpBasic();
	}
	
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		/*auth.inMemoryAuthentication()
		.withUser("admin").password("admin").authorities("admin")
		.and()
		.withUser("user").password("user").authorities("user");*/

		//jdbcauthentication
		//if we configure the AuthenticationManagerBuilder with the jdbcAuthentication, that jdbcAuthenticationmanager internally will use the
		//userdetails as the JdbcUserDetailsManager
		//AuthenticationManager will use jdbcauthenticationprovider, jdbcauthenticationprovider will use this JdbcUserDetailsManager
		//JdbcUserDetailsManager will excepting the users and authorities tables
		//the below boolean values for the users table's enable column values
		// 0 - disable
		// 1 - enable
		// /resources/sql/scripts.sql => run this scripts in sql editor of the mysql work bench
		//so, required tables were created i.e. users table and authorities table which are expected by the JdbcUserDetailsManager
		//jdbcAuthentication uses the JdbcUserDetailsManager
		//internally the AuthenticationManagerBuilder is building the AuthenticationManager(jdbcauthentication, inmemoryauthentication, ldapauthentication)
		//that AuthenticationManager internally uses the AuthenticationProvider uses the DaoAuthenticationProvider
		//DaoAuthenticationProvider will have retrieveUser, this method will use the underlying
		//getUserDetailsService().loadUserByUsername(username); while verifying the userdetails that were entered by us
		auth.jdbcAuthentication().dataSource(dataSource);
	}
	@Bean
	public PasswordEncoder passwordEncoder(){
		return NoOpPasswordEncoder.getInstance();
	}
	@Override
	public void configure(WebSecurity web) throws Exception {
		web.ignoring().antMatchers("/assets/**");
	}
}
================
default authenticationprovider is daoauthenticationprovider

@SuppressWarnings("deprecation")
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	private DataSource dataSource;
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http.authorizeRequests()
		.antMatchers("/").permitAll()
		.antMatchers("/dashboard").authenticated()
		.antMatchers("/doctor").authenticated()
		.and()
		.formLogin()
		.and()
		.httpBasic();
	}

	/*@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		auth.jdbcAuthentication().dataSource(dataSource);
	}*/
	//we can configure userdetailsmanager in another way such that without authenticationmanagerbuilder, we can configure
	//authenticationmanager will take the authentication request, that request gives to the authenticationprovider(default provider is daoauthenticationprovider)
	//that daoauthenticationprovider will use the userdetailsservice what we have exposed here and also use the passwordencoder
	//by using these two things, the authenticationprovder will take the decision whether the user is loggedin or not
	@Bean
	public UserDetailsService userDetailsService(){
		//inmemory
		/*InMemoryUserDetailsManager inMemoryUserDetailsManager = new InMemoryUserDetailsManager();
		UserDetails user1 = new User("admin", "admin", Arrays.asList(new SimpleGrantedAuthority("admin")));
		UserDetails user2 = new User("user", "user", Arrays.asList(new SimpleGrantedAuthority("user")));

		inMemoryUserDetailsManager.createUser(user1);
		inMemoryUserDetailsManager.createUser(user2);

		return inMemoryUserDetailsManager;*/

		//jdbc
		JdbcUserDetailsManager jdbcUserDetailsManager = new JdbcUserDetailsManager(dataSource);
		return jdbcUserDetailsManager;

		//upto here we have done usermanagement
		//cognito is the idp like wso2, keyclock
	}
	@Bean
	public PasswordEncoder passwordEncoder(){
		return NoOpPasswordEncoder.getInstance();
	}
	@Override
	public void configure(WebSecurity web) throws Exception {
		web.ignoring().antMatchers("/assets/**");
	}
}